library(biomaRt)
# Load my go-to libraries
library(dplyr)
library(ggplot2)
library(ggthemes)
library(stringr)
library(readr)
library(readxl)
library(reshape2)
# Packages for R markdown stuff
library(knitr)
library(shiny)
search()
rm(list = ls())
gc()
# Load libraries I'll need here
library(edgeR)
library(limma)
library(biomaRt)
library(ggfortify)
# Load my go-to libraries
library(dplyr)
library(ggplot2)
library(ggthemes)
library(stringr)
library(readr)
library(readxl)
library(reshape2)
# Packages for R markdown stuff
library(knitr)
library(shiny)
search()
source("R/metric_qc_functions.R")
# Function to build DGEList object, filter genes by keeping only those having %
# samples with at least N counts, and computes normalization from library sizes
setUpDGEList <- function(countData, geneData = NULL,
filterCount = 1, filterPercentage = 0.1)
{
d <- DGEList(counts = countData, genes = geneData)
# d <- calcNormFactors(d) # moved further down
# Filter all genes that do not have at least 'filterCount' counts per
# million in at least 'filterPercentage' percent of libraries
keepRows <- rowSums(round(cpm(d$counts)) >= filterCount) >=
filterPercentage*ncol(countData)
print(table(keepRows))
curDGE <- d[keepRows, ]
# James: I've added this change so that library sizes and normalization
# factors will always be updated/calculated after filtering genes
# reset library sizes
curDGE$samples$lib.size <- colSums(curDGE$counts)
# calculate normalization factors (effective library size =
# lib.size * norm.factor)
curDGE <- calcNormFactors(curDGE)
return(curDGE)
}
# Read CSV file with read counts
countFile <- "data/HMMF2ADXX_combined_counts.csv"
countDat <- read_csv(countFile) # 37991 obs. of  18 variables
# str(countDat)
# Read CSV file with RNAseq/alignment metrics
metricFile <- "data/HMMF2ADXX_combined_metrics.csv"
metricDat <- read_csv(metricFile) # 16 obs. of  71 variables
# str(metricDat)
# Read XLSX file with sample annotation
designFile <- "data/JMD119 Sample Information .xlsx"
designDat <- read_excel(designFile, skip = 1) # 36 obs. of 18 variables
# str(designDat)
# Separate gene counts and gene symbols into separate objects, reformat
# variable names in countDat to only include libID
geneDat <- data_frame(ensemblID = countDat$geneName)
countDat <- countDat %>%
select(-geneName)
names(countDat) <- names(countDat) %>%
str_extract("lib[0-9]+")
# Reformat variable names in metrics data frame
names(metricDat) <- names(metricDat) %>%
str_to_lower() %>%  # change variable names to lower case
make.unique(sep = "_") # de-dup variable names
names(metricDat)[1] <- "lib_id" # reformat libID variable name
# Reformat row names in metrics dataframe
metricDat <- metricDat %>%
mutate(lib_id = str_extract(lib_id, "lib[0-9]+"))
# Reformat variable names in design data frame
names(designDat) <- names(designDat) %>%
str_replace_all(" +", "_") %>% # replace spaces with underscores
str_replace_all("#", "num") %>%  # replace # with 'num'
str_replace_all("/", "_per_") %>%
str_replace_all("(\\(|\\))", "") %>% # remove parentheses
str_to_lower() %>% # change to lower case
str_replace("(?<=(lib))[a-z]+", "") %>% # replace 'library' with 'lib'
make.unique(sep = "_") # de-dup variable names
# Remove empty rows from design data frame
designDat <- designDat %>%
filter(!is.na(lib_id))
groupDat <- designDat %>%
# extract knockout status (WT or BCAP) and HSC population (long or short'
# term); combine into a single group vector
mutate(koStatus = as.factor(tolower(str_extract(sample_name, "WT|BCAP"))),
hscPop = as.factor(tolower(str_extract(hsc_population,
"Long|Short"))),
group = as.factor(str_c(koStatus, hscPop, sep = "_"))) %>%
select(libID = lib_id,
koStatus, hscPop, group)
# Pull out and format the subset of metrics to plot
metricSummary <- metricDat %>%
mutate(percentDuplication = unpaired_read_duplicates /
unpaired_reads_examined) %>%
select(libID = lib_id,
medianCVcoverage = median_cv_coverage,
fastqTotalReads = fastq_total_reads,
percentAligned = mapped_reads_w_dups,
percentDuplication)
sliderInput("alignCutoff", "percent aligned cutoff:",
min = 0, max = 1, step = 0.01,
value = 0.8)
sliderInput("readsCutoff", "total FASTQ reads cutoff:",
min = 0, max = 5e7, step = 1e5,
value = 1e6)
renderPlot({
yRange <-c(input$alignCutoff, 1)
xRange <- c(input$readsCutoff, max(metricSummary$fastqTotalReads) + 1e6)
metricSummary %>%
plot_metric("percentAligned", yRange, xRange)
})
countDat %>%
melt() %>%
mutate(count = value,
libID = variable) %>%
ggplot(aes(x = log2(count))) +
geom_density(aes(colour = libID), alpha = 0.2) +
theme_classic() +
scale_color_manual(values = colorRampPalette(colorblind_pal()(8))(16))
# Filter genes with (cpm > 10) in < 10% of samples
dge = setUpDGEList(countData = countDat, geneData = geneDat,
filterCount = 10,
filterPercentage = 0.20)
dge$counts %>%
melt() %>%
mutate(count = value,
libID = Var2) %>%
ggplot(aes(x = log2(count))) +
geom_density(aes(colour = libID), alpha = 0.2) +
theme_classic() +
scale_color_manual(values = colorRampPalette(colorblind_pal()(8))(16))
# pre-filter calculation of norm.factors
d1 <- DGEList(countDat)
d1 <- calcNormFactors(d1)
# initialize data frame to store results from both scenarios
normFactorTest <- d1$samples %>%
add_rownames(var = "libID") %>%
mutate(test = "preFilter") %>%
select(-group)
# post-filter calculation of norm.factors
filterCount <- 10
filterPercentage <- 0.2
d2 <- DGEList(countDat)
keepRows <- rowSums(round(cpm(d2$counts)) >= filterCount) >=
filterPercentage*ncol(countDat)
d2 <- d2[keepRows, ]
d2$samples$lib.size <- colSums(d2$counts)
d2 <- calcNormFactors(d2)
# update combined data frame
normFactorTest <- d2$samples %>%
add_rownames(var = "libID") %>%
mutate(test = "postFilter") %>%
select(-group) %>%
bind_rows(normFactorTest, .)
# plot norm.factors and lib.size.eff for both scenarios
normFactorTest %>%
mutate(test = relevel(as.factor(test), "preFilter"),
lib.size.eff = norm.factors * lib.size) %>%
melt(measure.vars = c("norm.factors", "lib.size.eff")) %>%
ggplot(aes(x = libID, y = value)) +
geom_point(aes(fill = test), shape = 21, size = 3,
colour = "white", alpha = 0.7,
position = position_jitter(width = 0.1, height = 0)) +
facet_wrap(~ variable, scales = "free_y") +
theme_classic() +
theme(axis.text.x = element_text(angle = 90),
panel.grid.major = element_line(colour = "grey", linetype = 3)) +
scale_fill_colorblind()
# Get MGI gene symbols corresponding to Ensembl Gene IDs
dgeGeneDat <- dge$genes
mart <- useMart(biomart = "ensembl", dataset = "mmusculus_gene_ensembl")
ens2Gene <- getBM(attributes = c("ensembl_gene_id", "mgi_symbol"),
filters = "ensembl_gene_id",
values = dgeGeneDat$ensemblID, mart = mart)
ens2Gene = ens2Gene[match(dgeGeneDat$ensemblID, ens2Gene$ensembl_gene_id), ]
# Insert MGI gene symbols for genes in DGE object gene info
dgeGeneDat <- dgeGeneDat %>%
mutate(mgiSymbol = ens2Gene$mgi_symbol,
mgiSymbol = ifelse(is.na(mgiSymbol), "NA", mgiSymbol))
dge$genes <- dgeGeneDat
pca <- prcomp(t(dge$counts))
autoplot(pca, data = groupDat, colour = 'group', label.size = 3,
shape = FALSE) +
scale_color_colorblind() +
guides(size = FALSE)
data_frame(pc = 1:length(pca$sdev), percSdev = pca$sdev / sum(pca$sdev)) %>%
ggplot(aes(x = pc, y = percSdev)) +
geom_bar(stat = "identity", alpha = 0.8) +
theme_classic() +
scale_fill_colorblind()
pca <- prcomp(t(dge$counts))
autoplot(pca, data = groupDat, colour = 'group', label.size = 3,
shape = FALSE) +
scale_color_colorblind() +
guides(size = FALSE)
data_frame(pc = 1:length(pca$sdev), percSdev = pca$sdev / sum(pca$sdev)) %>%
ggplot(aes(x = pc, y = percSdev)) +
geom_bar(stat = "identity", alpha = 0.8) +
theme_classic() +
scale_fill_colorblind()
autoplot(pca, data = groupDat, colour = 'group', label.size = 3,
shape = FALSE) +
scale_color_colorblind() +
guides(size = FALSE)
# Build data frame including design, metric, and other experimental variables
confoundDat <- designDat %>%
select(libID = lib_id, sort_date, age_in_weeks, ng_per_ul) %>%
left_join(metricSummary, by = c("libID" = "libID")) %>%
bind_cols(groupDat %>% select(-libID))
# Include PC1 values with data frame of (potentially) confounding variables
pc1Dat <- bind_cols(confoundDat, melt(pca$x[, 1], value.name = "pc1"))
# Plot PC1 against all other variables
pc1Dat %>%
melt(measure.vars = setdiff(names(confoundDat), "libID")) %>%
ggplot(aes(x = value, y = pc1)) +
geom_point() +
facet_wrap(~ variable, nrow = 2, scales = "free_x") +
stat_smooth(aes(group = 1)) +
theme_classic() +
theme(axis.text.x = element_text(angle = 90),
panel.grid.major = element_line(colour = "grey", linetype = 3)) +
scale_colour_colorblind()
bcapDat <- dge$counts[which(dge$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_fill_colorblind()
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot()
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(fill = koStatus)) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- dge$counts[which(dge$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(fill = koStatus), alpha = 0.8) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- dge$counts[which(dge$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(fill = koStatus), alpha = 0.8, colour = "white") +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- dge$counts[which(dge$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(fill = koStatus), alpha = 0.5) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- dge$counts[which(dge$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(colour = koStatus)) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- dge$counts[which(dge$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(colour = koStatus)) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind()
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- dge$counts[which(dge$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(colour = koStatus)) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
# Define the design matrix, only including terms corresponding to experimental
# groups; use voom to calculate transformed expression values
koDesign <- model.matrix(~ koStatus, data = groupDat)
koVoom <- voomWithQualityWeights(dge, design = koDesign,
plot = TRUE)
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- koVoom$E[which(koVoom$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(colour = koStatus)) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- koVoom$E[which(koVoom$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(colour = koStatus), outlier.shape = NA) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
?voom
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- koVoom$E[which(koVoom$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "log2_expression") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = log2_expression)) +
geom_boxplot(aes(colour = koStatus), outlier.shape = NA) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
View(bcapDat)
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- koVoom$E[which(koVoom$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "log2_expression") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = log2_expression)) +
geom_boxplot(aes(colour = koStatus), outlier.shape = NA) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.2),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
geom_text(aes(label = libID),
hjust = -0.2, vjust = 1.2, size = 4) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- koVoom$E[which(koVoom$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "log2_expression") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = log2_expression)) +
geom_boxplot(aes(colour = koStatus), outlier.shape = NA) +
geom_jitter(aes(fill = koStatus), position = position_jitter(width = 0.1),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
geom_text(aes(label = libID),
hjust = -0.2, vjust = 1.2, size = 4) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- koVoom$E[which(koVoom$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "log2_expression") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = log2_expression)) +
geom_boxplot(aes(colour = koStatus), outlier.shape = NA) +
geom_point(aes(fill = koStatus), position = position_jitter(width = 0.1),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
geom_text(aes(label = libID),
hjust = -0.2, vjust = 1.2, size = 4) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- koVoom$E[which(koVoom$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "log2_expression") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = log2_expression)) +
geom_boxplot(aes(colour = koStatus), outlier.shape = NA) +
geom_point(aes(fill = koStatus),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
geom_text(aes(label = libID),
hjust = -0.2, vjust = 1.2, size = 4) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
# Pull out raw counts for BCAP gene (Pik3ap1)
bcapDat <- dge$counts[which(dge$genes$mgiSymbol == "Pik3ap1"), ] %>%
melt(value.name = "count") %>%
add_rownames(var = "libID") %>%
mutate(koStatus = groupDat$koStatus,
hscPop = groupDat$hscPop)
# Plot BCAP counts by KO status and facet by HSC population
bcapDat %>%
ggplot(aes(x = koStatus, y = count)) +
geom_boxplot(aes(colour = koStatus), outlier.shape = NA) +
geom_point(aes(fill = koStatus),
size = 3, alpha = 0.8, colour = "white", shape = 21) +
geom_text(aes(label = libID),
hjust = -0.2, vjust = 1.2, size = 4) +
facet_wrap(~ hscPop) +
theme_classic() +
scale_color_colorblind() +
scale_fill_colorblind()
input <- list(alignCutoff = 1)
input$alignCutoff
sliderInput("alignCutoff", "percent aligned cutoff:",
min = 0, max = 1, step = 0.01,
value = 0.8)
sliderInput("readsCutoff", "total FASTQ reads cutoff:",
min = 0, max = 5e7, step = 1e5,
value = 1e6)
input <- list(alignCutoff = 0.8,
readsCutoff = 1e6,
covCutoff = 1.0)
renderPlot({
yRange <-c(input$alignCutoff, 1)
xRange <- c(input$readsCutoff, max(metricSummary$fastqTotalReads) + 1e6)
metricSummary %>%
plot_metric("percentAligned", yRange, xRange)
})
